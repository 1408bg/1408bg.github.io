# 1. forEach, map의 차이

forEach 함수는 배열의 각 요소를 직접 콜백의 인자로 주어 배열의 요소에 접근이 가능하며 반환값이 없다.

map 함수는 내부적으로 배열을 선언하여 그것에 인자로 받은 배열의 각 요소에 대한 콜백 함수의 반환값을 모아 반환한다.

# 2. 동기, 비동기

동기의 경우 동작이 언제 끝날지 명확한 작업, 함수를 나타낸다.

보통의 함수는 호출 시 내부 동작이 전부 실행된 후에 종료되는 동기의 형태를 가진다.

비동기의 경우 동작이 언제 끝날지 정해지지 않은 작업, 함수를 의미한다.

동기 작업은 요청한 작업이 완료될 때까지 코드의 실행이 멈추는 반면, 비동기 작업은 작업이 시작된 후에도 코드의 나머지 부분이 계속 실행된다.

비동기 작업이 완료되면 콜백 큐에 작업이 추가되며, 이벤트 루프에 의해 나중에 처리된다.

# 3. async, await

두 키워드는 비동기 함수를 다루기 위한 것이다.

await은 뒤의 비동기 작업을 끝까지 기다리도록 하는 역할을 가진다.

async은 해당 함수가 비동기 작업임을 명시하며, 내부적으로 해당 함수의 작업은 Promise 객체가 처리하도록 한다.

또한 비동기 작업이 끝나는 것을 기다리는 것 자체가 비동기 작업에 해당하기에, await은 async가 있는 비동기 함수에서만 사용 가능하다.

# 4. 비구조화 할당

비구조화는 객체와 같이 구조를 가진 값에서 특정 값만을 가져와서 할당하는 것이다.

객체의 경우 중괄호 사이에 객체의 키를 나열하여 그대로 가져오며, 식별자를 지정할 수 있다.

배열의 경우 대괄호 사이에 나열한 식별자에 배열의 요소가 순서대로 할당되며, 스프레드 연산자를 활용할 수도 있다.

# 5. const는 불변?

const는 요소에 접근하기 위한 직접적인 값을 고정함으로서, 변수의 재할당을 막는다.

이는 변수에 저장된 값이 불변이라는 의미가 아니며, 특히 객체나 배열과 같은 참조 자료형의 경우 내부 값의 수정이 가능하다.

그러나 freeze 메서드를 사용하여 객체의 속성을 변경할 수 없도록 할 수 있다.

# 6. js, jsx의 차이

js는 말 그대로 순수한 자바스크립트 파일이고, jsx는 자바스크립트와 HTML을 결합한 문법으로, 보통 React와 함께 사용된다.

jsx를 사용하면 HTML 태그를 자바스크립트 코드 내에서 직접 작성할 수 있으며, 이는 나중에 Babel을 통해 js로 컴파일된다.

# 7. React의 필요성

React는 상호작용이 많은 UI를 간편하게 만들 수 있도록 도와준다.

웹에서의 상호작용은 대부분 js를 통하여 처리한다.

순수 js의 경우 어느정도의 상호작용을 구현하려면 html파일로 작성된 태그를 렌더 후 DOM api로 가져오고, 해당 객체를 통하여 조작하는 과정이 필요하다.

이전에는 JQuery를 통하여 해당 과정을 단순해 했으나, React에서는 jsx문법을 통하여 html과 같이 DOM(정확히는 ReactDOM)객체를 선언형으로 생성하고, 컴포넌트 개념으로 가독성과 UI의 재사용성을 높인다.

또한 처음부터 객체를 통하여 UI를 그리기에 조작이 간편하고, 상태 관리 또한 지원한다.

# 8. CSR, SSR의 차이

각각 클라이언트 사이드 렌더링, 서버 사이드 렌더링을 의미한다.

CSR의 경우 서버에서 전달한 JS 코드가 클라이언트에서 UI를 그리며, SSR의 경우 보통 서버에서 템플릿 엔진을 통하여 UI를 미리 그린 후에 전달하여 클라이언트에서 즉시 보일 수 있도록 한다.

CSR의 경우 브라우저가 렌더링 이전의 내용을 알 수 없기에 SEO에 불리하다는 단점이 있다.

# 9. React 컴포넌트

컴포넌트는 UI를 구성하는 React의 기본 단위이다.

컴포넌트는 재사용 가능하며, HTML, CSS, 자바스크립트를 결합하여 UI의 특정 부분을 표현한다. 주로 함수형과 클래스형 두 가지로 나뉘며, 각 컴포넌트는 자체적인 상태와 속성을 가질 수 있어, UI를 쪼개서 구조적으로 구현할 수 있다.

# 10. React hook

함수형 컴포넌트에서 상태 관리와 생명주기 기능을 다룰 수 있도록 하며, 대표적인 훅으로 useState, useEffect, useContext 등이 있다.

이를 통하여 클래스형 컴포넌트에서만 가능했던 기능들을 함수형 컴포넌트에서도 구현할 수 있게 된다.

# 11. useEffect의 의존성 배열

useEffect의 함수는 첫번째 인자로 콜백 함수를 받고, 두번째 인자로 의존성 배열을 받는다.

의존성 배열의 변경이 콜백 함수의 실행 조건이며, 빈 배열의 경우에는 첫 렌더링 때에만 실행된다.

# 12. 패키지 매니저

패키지 매니저는 패키지를 관리하는 도구이다.

패키지의 설치, 업데이트, 제거, 의존성 관리 등을 자동화하여 DX를 높인다.

패키지 매니저마다 다른 방식의 의존성 관리를 수행하기에 유령 의존성, 패키지 중복 설치 등의 문제가 발생할 수 있다.

# 13. state, props의 차이

state는 상태관리를 위한 React의 기능 중 하나로 변경될 수 있고 UI 변경이 의존하는 동적인 데이터이다.

props는 부모 컴포넌트가 자식 컴포넌트로 전달하는 데이터로 이는 함수의 인자와 비슷하다 수정할 수 없으며, 정적이다.

# 14. Virtual DOM

React는 DOM 객체를 조작하기 전에 가상 DOM을 생성하고 그곳에서 변경된 UI만을 실제 DOM 조작의 대상으로 한다.

이를 통하여 부분적으로는 성능이 향상될 수 있고, 효율적인 UI변경이 가능해진다.

# 15. export, export default의 차이

export는 es6에서 추가된 module 기능의 일부로, 특정 변수를 모듈로서 내보낼 수 있다.

export의 경우 여러 변수를 내보낼 수 있기에 보통 비구조화 할당을 통하여 import하지만 export default의 경우 한 파일에서 하나의 변수만 내보낼 수 있기에 비구조화 할당 없이 import가 가능하다.

# 16. SEO의 중요성

검색 엔진 최적화는 사이트가 검색 엔진 결과에서 높은 순위를 차지하도록 최적화 하는 것이다. SEO가 높은 사이트는 사용자에게 자주 노출되고, 이것은 곧 트래픽 증가로 이어진다.

내부 사이트의 경우, SEO가 중요하지 않을 수 있다.

# 17. React의 state

React에서 state는 컴포넌트의 동적 데이터를 저장하는 객체이다.

state는 컴포넌트 내부에서 관리되며, 상태가 변경되면 React는 자동으로 해당 컴포넌트를 다시 렌더링 하는 것으로 UI 변경이 이루어진다.

그렇기에 컴포넌트의 UI 변경은 보통 내부state에 의존한다.

# 18. react-router-dom 라이브러리

해당 라이브러리는 React 애플리케이션에서 라우팅을 관리하며, URL 변경에도 페이지 새로고침 없이 해당 path에 해당하는 컴포넌트를 렌더링 할 수 있도록 한다.

# 19. package.json

package.json은 Node.js에서 사용되며, 메타데이터와 의존성을 관리하는데에 사용된다.

프로젝트의 이름, 버전, 의존성, 스크립트, 저작권 정보 등을 포함하며, 이 파일을 통하여 다른 개발자들이 프로젝트를 동일한 환경에서 실행할 수 있도록 한다.

# 20. axios, fetch의 차이

fetch는 브라우저 내장 함수로, 간단하게 API 호출이 가능하다.

axios는 API 호출을 위한 라이브러리로 Node.js에서 사용할 수 있으며 기본 설정, 인터셉터, 자동 json 파싱과 같은 추가 기능을 제공한다.

# 21. react-router-dom의 필요성

새로고침 없는 라우팅은 UX를 향상시키며, 라이브러리 내부의 강력한 추가 기능을 통한 라우트 보호, 중첩 라우드, 동적 라우트 등이 가능하다.

# 22. 모노레포

모노레포는 여러 프로젝트를 하나의 레포지토리에서 관리하는 것이다. (.git이 여러개)

각 프로젝트는 독립적으로 관리할 수 있으며, 코드의 재사용성을 높이고 의존성 관리를 공유하는 것에 효율적이다.

# 23. Gitflow

Git의 브랜치 관리 전략 중 하나이다.

main에는 현재 배포 버전을, develop에는 다음 배포 버전을, feature에는 신기능 개발을, release에는 배포 직전의 것을. hotfix에는 현재 배포의 수정을 다룬다.

# 24. 프로토타입

자바스크립트는 자바와 같은 클래스 기반 언어와 달리 프로토타입을 기반으로 하여 객체지향을 구현하였다.

프로토타입은 객체의 조상과 같은 역할을 하며, 자바스크립트에서 상속 및 멤버 탐색을 주도한다.

객체에서 멤버 접근을 할 때 객체의 레벨에 해당 멤버가 없으면 객체의 프로토타입으로, 프로토타입에 없으면 그것의 프로토타입으로 탐색을 진행하여 프로토타입 체인의 끝까지 도달하는 것으로 탐색이 중지된다.

# 25. 클래스형 컴포넌트, 함수형 컴포넌트의 차이

클래스형 컴포넌트는 ES6의 클래스 문법을 사용하며 React.Component클래스를 상속하기에 state와 그것을 다루는 메서드에 직접 접근이 가능하다.

함수형 컴포넌트는 본래 컴포넌트 클래스에서 render 메서드만 구현하는 것으로 비교적 간단하며, React hook을 사용하여 state에 접근이 가능하다.

# 26. ES6

ES6은 2015년에 이루어진 Javascript 버전 업데이트를 의미한다.

let, const, 클래스, 화살표 함수, 모듈, 비구조화 등이 추가되었다.

class 문법의 경우 프로토타입 상속을 문법적으로 감싼 것이다.

# 27. SPA

SPA는 하나의 HTML로 구성된 사이트를 의미한다.

새 파일을 로드하지 않고 일부만 동적으로 로드하는 것으로 페이지간 전환을 구현하여 UX 향상과 성능 최적화가 가능하다.
