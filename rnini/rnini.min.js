/**
* DOM 요소로 변환 가능한 요소의 원형입니다.
* 좌표, 크기, 하위 요소를 가지고, 그것을 DOM으로 변환합니다.
*/
class Entity {
  /**
  * @param {Position} position 위치를 지정하는 Position 객체
  * @param {Size} size 크기를 지정하는 Size 객체
  * @param {string|HTMLElement|Color} content 배경 색, 배경 이미지 또는 하위 DOM 요소
  * @param {int} layer 레이어 순서
  */
  constructor(position, size, content, layer) {
    this.position = position;
    this.size = size;
    this.content = content;
    this.originalContent = ()=>content;
    this.element = null;
    this.layer = layer??0;
  }

  /**
  * Entity에 해당하는 div 요소를 생성합니다.
  * @returns {HTMLElement} div 요소
  */
  render() {
    const entity = document.createElement('div');
    entity.style.position = 'absolute';
    entity.style.width = `${this.size.width}px`;
    entity.style.height = `${this.size.height}px`;
    entity.style.left = `${this.position.x}px`;
    entity.style.top = `${this.position.y}px`;
    entity.style.zIndex = this.layer;

    if (typeof this.content === 'string') {
      entity.style.backgroundImage = `url(${this.content})`;
      entity.style.backgroundSize = 'cover';
    } else if (this.content instanceof HTMLElement) {
      entity.appendChild(this.originalContent());
    } else if (this.content instanceof Color) {
      entity.style.backgroundColor = this.content.toString();
    }

    this.element = entity;
    return entity;
  }

  /**
  * 자신의 복사본을 반환합니다.
  * @returns {Entity} 새로운 Entity 객체
  */
  copy() {
    return new Entity(this.position, this.size, this.content, this.layer);
  }

  /**
  * Entity를 제거합니다.
  */
  destroy() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }

  /**
  * 요소의 가시성을 변경합니다.
  * @param {bool} visible 가시성
  */
  visibility(visible) {
    this.originalContent().style.visibility = visible ? "visible" : "hidden";
  }
}

/**
* click 이벤트를 감지할 수 있는 Entity입니다.
* click 요소를 클릭하면 onClick 콜백이 실행됩니다.
*/
class Clickable extends Entity {
  /**
  * @param {Position} position 위치를 지정하는 Position 객체
  * @param {Size} size 크기를 지정하는 Size 객체
  * @param {string|HTMLElement|Color} content 배경색, 배경 이미지 또는 하위 DOM 요소
  * @param {Function} onClick 클릭 시 호출될 함수
  */
  constructor(position, size, content, onClick) {
    super(position, size, content);
    this.onClick = onClick;
  }

  /**
  * Entity에 해당하는 div 요소를 생성하고 클릭 이벤트 리스너를 추가합니다.
  * @returns {HTMLElement} div 요소
  */
  render() {
    const entity = super.render();
    entity.addEventListener('click', ()=>this.onClick(this));
    return entity;
  }

  /**
  * 자신의 복사본을 반환합니다.
  * @returns {Clickable} 새로운 Clickable 객체
  */
  copy() {
    return new Clickable(this.position, this.size, this.content, this.onClick);
  }

  /**
  * Clickable을 제거합니다.
  */
  destroy() {
    if (this.element) {
      this.element.removeEventListener('click', this.clickHandler);
    }
    super.destroy();
  }

  /**
  * Entity 객체를 Clickable 객체로 변환합니다.
  * @param {Entity} entity - 변환할 Entity 객체
  * @param {Function} onClick - 클릭 시 호출될 함수
  * @returns {Clickable} 새로운 Clickable 객체
  */
  static cast(entity, onClick) {
    return new Clickable(entity.position, entity.size, entity.content, onClick);
  }
}

/**
* keydown 이벤트를 감지할 수 있는 Entity입니다.
* 키보드 키가 눌리면 onKeydown 콜백이 실행됩니다.
*/
class KeyListenable extends Entity {
  /**
  * @param {Position} position - 위치를 지정하는 Position 객체
  * @param {Size} size - 크기를 지정하는 Size 객체
  * @param {string|HTMLElement|Color} content - 배경색, 배경 이미지 또는 하위 DOM 요소
  * @param {Function} onKeydown - 키보드 입력 시 호출될 함수, 인자로 입력된 키를 받습니다.
  */
  constructor(position, size, content, onKeydown) {
    super(position, size, content);
    this.onKeydown = onKeydown;
    this.keydownHandler = this.handleKeydown.bind(this);
    this.listenerAdded = false;
  }

  /**
  * 키보드 입력 이벤트 핸들러입니다.
  * @param {KeyboardEvent} event - 키보드 이벤트 객체
  */
  handleKeydown(event) {
    if (this.onKeydown) {
      this.onKeydown(event.key, this);
    }
  }

  /**
  * Entity에 해당하는 div 요소를 생성하고 키보드 입력 이벤트 리스너를 추가합니다.
  * @returns {HTMLElement} div 요소
  */
  render() {
    const entity = super.render();
    entity.style.position = 'absolute';
    entity.style.left = `${this.position.x}px`;
    entity.style.top = `${this.position.y}px`;
  
    if (!this.listenerAdded) {
      document.addEventListener('keydown', this.keydownHandler);
      this.listenerAdded = true;
    }
  
    return entity;
  }

  /**
  * 자신의 복사본을 반환합니다.
  * @returns {KeyListenable} 새로운 KeyListenable 객체
  */
  copy() {
    return new KeyListenable(this.position, this.size, this.content, this.onKeydown);
  }

  /**
  * Keylistenable을 제거합니다.
  */
  destroy() {
    if (this.listenerAdded) {
      document.removeEventListener('keydown', this.keydownHandler);
      this.listenerAdded = false;
    }
    super.destroy();
  }
  
  /**
  * Entity 객체를 KeyListenable 객체로 변환합니다.
  * @param {Entity} entity - 변환할 Entity 객체
  * @param {Function} onKeydown - 키보드 입력 시 호출될 함수, 인자로 입력된 키를 받습니다.
  * @returns {KeyListenable} 새로운 KeyListenable 객체
  */
  static cast(entity, onKeydown) {
    return new KeyListenable(entity.position, entity.size, entity.content, onKeydown);
  }
}

/**
* 값을 변경 감지할 수 있도록 `Proxy`를 사용하여 Entity를 감쌉니다.
* @param {Entity} entity 변경을 감지할 Entity
* @param {Function} onChange 변경 감지 시 실행될 함수
* @returns {Proxy} Proxy로 감싸진 Entity
*/
/**
* 값을 변경 감지할 수 있도록 Proxy로 Entity를 감쌉니다.
* @param {Entity} entity 변경을 감지할 Entity
* @param {Function} onChange 변경 감지 시 실행될 함수
* @returns {Proxy} Proxy로 감싸진 Entity
*/
function createObservableEntity(entity, onChange) {
  let isUpdating = false;

  function createProxy(value) {
    if (typeof value === 'object' && value !== null) {
      return new Proxy(value, {
        set(target, property, newValue) {
          if (target[property] !== newValue) {
            if (typeof newValue === 'object' && newValue !== null) {
              newValue = createProxy(newValue);
            }
            target[property] = newValue;

            if (!isUpdating && typeof onChange === 'function') {
              isUpdating = true;
              onChange(property, newValue);
              isUpdating = false;
            }
          }
          return true;
        }
      });
    }
    return value;
  }

  function wrapEntityProperties(entity) {
    for (const property in entity) {
      if (entity.hasOwnProperty(property)) {
        const value = entity[property];
        if (typeof value === 'object' && value !== null) {
          entity[property] = createProxy(value);
        }
      }
    }
  }

  wrapEntityProperties(entity);

  return new Proxy(entity, {
    set(target, property, value) {
      if (target[property] !== value) {
        if (typeof value === 'object' && value !== null) {
          value = createProxy(value);
        }
        target[property] = value;

        if (!isUpdating && typeof onChange === 'function') {
          isUpdating = true;
          onChange(property, value);
          isUpdating = false;
        }
      }
      return true;
    }
  });
}

class Prefab {
  /**
  * @param {Entity} entity 복제할 Entity 객체 또는 그를 상속한 객체
  * @param {Game} game entity가 추가될 game 객체
  */
  constructor(entity, game) {
    this.entityTemplate = entity;
    this.game = game;
    this.instantiatedEntities = new Set();
  }

  /**
  * 저장된 Entity의 복제본을 생성하여 game에 추가합니다.
  * @param {Position} [position] 복제본의 위치 (옵션)
  */
  instantiate(position) {
    const entityCopy = this.entityTemplate.copy();

    if (position) {
      entityCopy.position = position;
    }

    this.instantiatedEntities.add(this.game.addEntity(entityCopy));
  }

  /**
  * 생성한 복제본을 제거합니다.
  * @param {Entity} entity 삭제할 복제본
  */
  destroy(entity) {
    if (this.instantiatedEntities.has(entity)) {
      this.game.removeEntity(entity);
      this.instantiatedEntities.delete(entity);
    }
  }

  /**
  * 생성한 모든 복제본을 제거합니다.
  */
  destroyAll() {
    for (const entity of this.instantiatedEntities) {
      this.destroy(entity);
    }
  }

  /**
  * 생성된 복제본의 개수를 반환합니다.
  * @returns {number} 생성된 복제본의 개수
  */
  count() {
    return this.instantiatedEntities.size;
  }
}

/**
 * 일정 시간동안 특정 값에 Lerp를 적용하여 함수를 실행합니다.
 * @param {float} start 시작 값
 * @param {float} end 종료 값
 * @param {Function} lerpFunc Lerp클래스의 lerp함수
 * @param {Duration} duration 시간
 * @param {Function} callback 현재 값을 받을 함수
 * @param {Function} onFinished 모든 작업이 완료되었을 때 호출될 함수
 * @returns {Function} 애니메이션을 중단하는 stop 함수
 */
function animate(start, end, lerpFunc, duration, callback, onFinished) {
  let startTime = null;
  let playing = true;
  const d = duration.value;

  function stop() {
    playing = false;
  }

  function animationFrame(time) {
    if (!startTime) startTime = time;
    let elapsed = time - startTime;

    let t = Math.min(elapsed / d, 1);
    let currentValue = lerpFunc(start, end, t);

    callback(currentValue);

    if (t < 1 && playing) {
      requestAnimationFrame(animationFrame);
    } else if (t >= 1 && playing) {
      onFinished();
    }
  }

  requestAnimationFrame(animationFrame);

  return stop;
}

/**
* 색상을 나타내는 클래스입니다.
* 여러 메서드를 통하여 rgba 기반의 색상을 저장합니다.
*/
class Color {
  /**
  * @param {int} r red (0~255)
  * @param {int} g green (0~255)
  * @param {int} b blue (0~255)
  * @param {float} a alpha (0.0~1.0)
  */
  constructor(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  /**
  * 불투명한 색상을 생성합니다.
  * @param {int} r red (0~255)
  * @param {int} g green (0~255)
  * @param {int} b blue (0~255)
  * @returns {Color} 색상
  */
  static fromRGB(r, g, b) {
    return new Color(r, g, b, 1);
  }

  /**
  * 16진수 색상을 기반으로 색상을 생성합니다.
  * @param {string} hex 16진수 형식의 색상 코드 (#RRGGBB 또는 #RRGGBBAA)
  * @returns {Color} 색상
  */
  static fromHex(hex) {
    hex = hex.replace('#', '');

    let r, g, b, a = 1;

    if (hex.length === 6) {
      r = parseInt(hex.substring(0, 2), 16);
      g = parseInt(hex.substring(2, 4), 16);
      b = parseInt(hex.substring(4, 6), 16);
    }
    else if (hex.length === 8) {
      r = parseInt(hex.substring(0, 2), 16);
      g = parseInt(hex.substring(2, 4), 16);
      b = parseInt(hex.substring(4, 6), 16);
      a = parseInt(hex.substring(6, 8), 16) / 255;
    } else {
      throw new Error('Invalid hex color format');
    }

    return new Color(r, g, b, a);
  }

  /**
  * 자신의 복사본을 반환합니다.
  * @returns {Color} 새로운 Color 객체
  */
  copy() {
    return new Color(this.r, this.g, this.b, this.a);
  }

  /**
  * 색상을 문자열로 반환합니다.
  * @returns {string} rgba() 형식의 색상 문자열
  */
  toString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
  }
}

/**
* 2차원 좌표를 나타내는 클래스입니다. 
* 좌표 (x, y)를 기반으로 위치를 설정하고, 이동하거나 두 좌표 사이의 거리 및 각도를 계산할 수 있습니다.
*/
class Position {
  /**
  * 2차원 위치를 지정합니다.
  * @param {float} x x 좌표
  * @param {float} y y 좌표
  */
  constructor (x, y) {
    this.x = x;
    this.y = y;
  }

  /**
  * 현재 위치의 복사본을 반환합니다.
  * @returns {Position} 새로운 위치 객체
  */
  copy() {
    return new Position(this.x, this.y);
  }

  /**
  * position만큼 자신의 위치를 변경합니다.
  * @param {Position} position
  * @returns {Position}
  */
  move(position) {
    this.x += position.x;
    this.y += position.y;
    return this;
  }

  /**
  * position과 자신의 위치 사이의 거리 제곱을 반환합니다.
  * @param {Position} position
  * @returns {float} 거리
  */
  distance(position) {
    return (this.x - position.x) ** 2 + (this.y - position.y) ** 2
  }

  /**
  * 두 위치가 동일한지 확인합니다.
  * @param {Position} position
  * @returns {boolean} 동일 여부
  */
  equals(position) {
    return this.x === position.x && this.y === position.y;
  }

  /**
  * 두 위치 사이의 각도를 반환합니다.
  * @param {Position} position
  * @returns {float} 라디안 단위의 각도
  */
  angle(position) {
    return Math.atan2(position.y - this.y, position.x - this.x);
  }
}

/**
* 2차원 크기를 나타내는 클래스입니다. 
* width, height를 기반으로 크기를 설정합니다.
*/
class Size {
  /**
  * 2차원 크기를 지정합니다.
  * @param {float} width 가로 길이
  * @param {float} height 세로 길이
  */
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.size = width * height;
  }

  /**
  * 요소에 맞춘 크기를 반환합니다.
  * @param {HTMLElement} element 크기의 기준이 될 요소
  * @returns {Size}
  */
  static fitOf(element) {
    const target = element.cloneNode(true);
    target.style.visibility = 'hidden';
    target.style.position = 'absolute';
    target.style.left = '-9999px';
    document.body.appendChild(target);
    const size = {
      width: target.offsetWidth,
      height: target.offsetHeight
    };
    document.body.removeChild(target);
    return new Size(
      size.width,
      size.height
    );
  }

  /**
  * 현재 크기의 복사본을 반환합니다.
  * @returns {Size} 새로운 크기 객체
  */
  copy() {
    return new Size(this.width, this.height);
  }

  /**
  * 자신이 size를 포함할 수 있는지 확인합니다.
  * @param {Size} size
  * @returns {boolean} 포함 여부
  */
  contains(size) {
    return (this.width >= size.width) && (this.height >= size.height);
  }

  /**
  * 두 크기가 동일한지 확인합니다.
  * @param {Size} size
  * @returns {boolean} 동일 여부
  */
  equals(position) {
    return this.width === position.width && this.height === position.height;
  }

  /**
  * 크기를 입력된 배율로 확대하거나 축소합니다.
  * @param {number} factor 배율
  */
  scale(factor) {
    const scaleFactor = Math.sqrt(factor);
    this.width *= factor;
    this.height *= factor;
    this.size = this.width * this.height;
  }

  /**
  * 크기를 가로, 세로 각각 주어진 값만큼 증가시킵니다.
  * @param {number} widthIncrement 가로 증가 값
  * @param {number} heightIncrement 세로 증가 값
  */
  increase(widthIncrement, heightIncrement) {
    this.width += widthIncrement;
    this.height += heightIncrement;
    this.size = this.width * this.height;
  }
}

class ProgressIndicator extends Entity {
  /**
  * 
  * @param {Position} position 위치
  * @param {Size} size 크기
  * @param {HTMLElement} body 요소
  * @param {number} value 진행도 (0~100)
  */
  constructor(position, size, body, value) {
    super(position, size, body, 10);
    this.value = value;
  }
  /**
  * 선형 ProgressIndicator를 반환합니다.
  * @param {Position} position 위치
  * @param {Size} size 크기
  * @param {Color} backgroundColor 배경 색
  * @param {Color} progressColor 진행 막대 색
  * @param {number} [value] 진행도 (0~100)
  * @param {number} [duration] 변경 속도
  * @returns {ProgressIndicator} LineProgressIndicator
  */
  static line(position, size, backgroundColor, progressColor, value = 0, duration = 0) {
    const content = document.createElement("div");
    content.style.width = `${size.width}px`;
    content.style.height = `${size.height}px`;
    content.style.backgroundColor = backgroundColor.toString();
    const line = document.createElement("div");
    line.style.width = `${value}%`;
    line.style.height = `${size.height}px`;
    line.style.transition = `width ${duration}s`;
    line.style.backgroundColor = progressColor.toString();
    line.style.zIndex = "11";
    content.appendChild(line);
    return new ProgressIndicator(
      position,
      size,
      content,
      value
    );
  }

  /**
  * 진행도를 변경합니다.
  * @param {number} value 진행도 (0~100)
  */
  setValue(value) {
    this.originalContent().children[0].style.width = `${value}%`;
  }

  /**
  * 배경 색을 변경합니다.
  * @param {Color} color 배경 색
  */
  setBackgroundColor(color) {
    this.originalContent().style.backgroundColor = color.toString();
  }

  /**
  * 진행 막대 색을 변경합니다.
  * @param {Color} color 진행 막대 색
  */
  setProgressColor(color) {
    this.originalContent().children[0].style.backgroundColor = color.toString();
  }
}

class Text extends Entity {
  /**
  * @param {Position} position 위치를 지정하는 Position 객체
  * @param {string} text 문자
  * @param {String} [fontSize] 폰트 크기
  * @param {String} [fontWeight] 폰트 굵기
  * @param {String|Color} [color] 색상
  */
  constructor(position, text, fontSize = "16px", fontWeight = "400", color = "black") {
    const content = document.createElement("span");
    content.style.fontSize = fontSize;
    content.style.fontWeight = fontWeight;
    if (color instanceof Color) {
      content.style.color = color.toString();
    } else {
      content.style.color = color;
    }
    content.innerText = text;
    const size = Size.fitOf(content);
    super(position, size, content);
  }

  /**
  * 자신의 값을 변경합니다.
  * @param {String} text
  */
  setText(text) {
    this.originalContent().innerText = text;
  }

  /**
  * 자신의 값을 추가합니다.
  * @param {String} text 
  */
  addText(text) {
    this.originalContent().innerText += text;
  }

  /**
  * 자신의 색을 변경합니다.
  * @param {Color} color 
  */
  setColor(color) {
    this.originalContent().style.color = color.toString();
  }
}

class TextButton extends Entity {
  /**
  * 글자를 content로 가지는 버튼을 생성합니다.
  * @param {Text} text 글자
  * @param {Function} onClick 클릭 시 실행될 함수
  */
  constructor(text, onClick) {
    super(text.position, text.size, text, 10);
    text.position = new Position(0, 0);
    this.onClick = onClick;
    /**
    * @type {Function}
    */
    this.text = ()=>text;
  }

  render() {
    const entity = document.createElement('div');
    entity.style.position = 'absolute';
    entity.style.width = `${this.size.width}px`;
    entity.style.height = `${this.size.height}px`;
    entity.style.left = `${this.position.x}px`;
    entity.style.top = `${this.position.y}px`;
    entity.style.zIndex = this.layer;

    entity.appendChild(this.text().render());

    this.element = entity;
    entity.addEventListener('click', ()=>this.onClick(this));
    return entity;
  }

  /**
  * 요소의 가시성을 변경합니다.
  * @param {bool} visible 가시성
  */
  visibility(visible) {
    this.text().visibility(visible);
  }
}

/**
* 시간을 나타내는 클래스입니다.
* 각 단위별로 시간을 초기화할 수 있습니다.
*/
class Duration {
  constructor({ milisecond = 0, second = 0, minute = 0, hour = 0, day = 0 }) {
    this.value = milisecond 
    + second * 1000
    + minute * 60 * 1000
    + hour * 60 * 60 * 1000
    + day * 24 * 60 * 60 * 1000;
  }
}

/**
* 러프 함수를 제공하는 클래스입니다.
* 인자로 시작 값, 종료 값, 진행도를 받습니다.
*/
class Lerp {  
  static lerp(start, end, t) {
    return start + (end - start) * t;
  }

  static easeInSine(start, end, t) {
    return start + (end - start) * (1 - Math.cos((t * Math.PI) / 2));
  }

  static easeOutSine(start, end, t) {
    return start + (end - start) * Math.sin((t * Math.PI) / 2);
  }

  static easeInOutSine(start, end, t) {
    return start + (end - start) * (-(Math.cos(Math.PI * t) - 1) / 2);
  }

  static easeInQuad(start, end, t) {
    return start + (end - start) * t * t;
  }

  static easeOutQuad(start, end, t) {
    return start + (end - start) * (1 - (1 - t) * (1 - t));
  }

  static easeInOutQuad(start, end, t) {
    return t < 0.5
      ? start + (end - start) * (2 * t * t)
      : start + (end - start) * (1 - Math.pow(-2 * t + 2, 2) / 2);
  }
}

/**
* Entity를 root에 추가하고 변경을 감지할 수 있는 Class입니다.
* addEntity로 Entity를 추가합니다.
*/
class Game {
  /**
   * 게임이 렌더링될 루트 요소를 지정합니다.
   * @param {HTMLElement} root
   */
  constructor(root) {
    this.root = root;
    root.style.position = "relative";
    this.width = root.clientWidth;
    this.height = root.clientHeight;
    this.entities = new Map();
  }

  /**
  * Entity를 추가하고 root에 렌더링합니다.
  * 상태 변화가 자동으로 감지됩니다.
  * @param {Entity} entity 추가할 Entity 객체
  * @param {int} layer 객체의 z-index
  * @returns {HTMLElement} 감지를 위한 Proxy 객체
  */
  addEntity(entity, layer) {
    if (layer) {
      entity.layer = layer;
    }
    const observableEntity = createObservableEntity(entity, () => {
      this.updateDOM(observableEntity);
    });
  
    const entityElement = observableEntity.render();
    this.root.appendChild(entityElement);
    this.entities.set(observableEntity, entityElement);

    return observableEntity;
  }

  /**
  * 상태가 변경된 엔티티의 DOM을 업데이트하는 메서드
  * @param {Entity} entity 업데이트할 Entity
  */
  updateDOM(entity) {
    if (this.entities.has(entity)) {
      const oldElement = this.entities.get(entity);
      const newElement = entity.render();
      this.root.replaceChild(newElement, oldElement);
      this.entities.set(entity, newElement);
    }
  }

  /**
  * 엔티티를 root에서 제거하는 메서드
  * @param {Entity} entity 제거할 Entity 객체
  */
  removeEntity(entity) {
    if (this.entities.has(entity)) {
      const element = this.entities.get(entity);
      this.root.removeChild(element);
      this.entities.delete(entity);
    }
  }
}
